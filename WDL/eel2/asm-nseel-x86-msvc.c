// THIS FILE AUTOGENERATED FROM asm-nseel-x86-gcc.c by a2i.php

#if EEL_F_SIZE == 8
  #define EEL_ASM_TYPE qword ptr
#else
  #define EEL_ASM_TYPE dword ptr
#endif

/* note: only EEL_F_SIZE=8 is now supported (no float EEL_F's) */

__declspec(naked) void nseel_asm_1pdd(void)
{
  __asm {

    mov edi, 0xfefefefe;
#ifdef TARGET_X64
    sub rsp, 128;
    fstp qword ptr [rsp];
    movq xmm0, [rsp];
    #ifdef AMD64ABI
       mov r15, rsi;
       call edi;
       mov rsi, r15;
    #else
       call edi;
    #endif
    movq [rsp], xmm0;
    fld qword ptr [rsp];
    add rsp, 128;
#else
    sub esp, 16;
    fstp qword ptr [esp];
    call edi;
    add esp, 16;
#endif

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_1pdd_end(void){}

__declspec(naked) void nseel_asm_2pdd(void)
{
  __asm {

    mov edi, 0xfefefefe;
#ifdef TARGET_X64
    sub rsp, 128;
    fstp qword ptr [rsp+8];
    fstp qword ptr [rsp];
    movq xmm1, [rsp+8];
    movq xmm0, [rsp];
    #ifdef AMD64ABI
      mov r15, rsi;
      call edi;
      mov rsi, r15;
    #else
      call edi;
    #endif
    movq [rsp], xmm0;
    fld qword ptr [rsp];
    add rsp, 128;
#else
    sub esp, 16;
    fstp qword ptr [esp+8];
    fstp qword ptr [esp];
    call edi;
    add esp, 16;
#endif

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_2pdd_end(void){}

__declspec(naked) void nseel_asm_2pdds(void)
{
  __asm {

    mov eax, 0xfefefefe;
#ifdef TARGET_X64
    sub rsp, 128;
    fstp qword ptr [rsp];
    movq xmm0, [rdi];
    movq xmm1, [rsp];
    #ifdef AMD64ABI
      mov r15, rsi;
      mov r14, rdi;
      call eax;
      mov rsi, r15;
      movq [r14], xmm0;
      mov rax, r14; /* set return value */
    #else
      call eax;
      movq [edi], xmm0;
      mov eax, edi; /* set return value */
    #endif
    add rsp, 128;
#else
    sub esp, 8;
    fstp qword ptr [esp];
    push dword ptr [edi+4]; /* push parameter */
    push dword ptr [edi];    /* push the rest of the parameter */
    call eax;
    add esp, 16;
    fstp qword ptr [edi]; /* store result */
    mov eax, edi; /* set return value */
#endif

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_2pdds_end(void){}



//---------------------------------------------------------------------------------------------------------------


// do nothing, eh
__declspec(naked) void nseel_asm_exec2(void)
{
   __asm {
      
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }
}
__declspec(naked) void nseel_asm_exec2_end(void) { }



__declspec(naked) void nseel_asm_invsqrt(void)
{
  __asm {
    mov edx, 0x5f3759df;
    fst dword ptr [esi];
#ifdef TARGET_X64
    mov rax, 0xfefefefe;
    sub ecx, ecx;
    fmul EEL_ASM_TYPE [rax];
#else
#if EEL_F_SIZE == 8
_emit 0xDC; // fmul qword ptr [0xfefefefe]
_emit 0x0D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fmul dword ptr [0xfefefefe]
_emit 0x0D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
#endif
    mov ecx, dword ptr [esi];
    sar ecx, 1;
    sub edx, ecx;
    mov dword ptr [esi], edx;
    fmul dword ptr [esi];
    fmul dword ptr [esi];
#ifdef TARGET_X64
    mov rax, 0xfefefefe;
    fadd EEL_ASM_TYPE [rax];
#else
#if EEL_F_SIZE == 8
_emit 0xDC; // fadd qword ptr [0xfefefefe]
_emit 0x05;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fadd dword ptr [0xfefefefe]
_emit 0x05;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
#endif
    fmul dword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_invsqrt_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_sin(void)
{
  __asm {
    fsin;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_sin_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_cos(void)
{
  __asm {
    fcos;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_cos_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_tan(void)
{
  __asm {
    fptan;
    fstp st(0);
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_tan_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_sqr(void)
{
  __asm {
    fmul st(0), st(0);
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_sqr_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_sqrt(void)
{
  __asm {
    fabs;
    fsqrt;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_sqrt_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_log(void)
{
  __asm {
    fldln2;
    fxch;
    fyl2x;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_log_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_log10(void)
{
  __asm {
    fldlg2;
    fxch;
    fyl2x;

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_log10_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_abs(void)
{
  __asm {
    fabs;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_abs_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_assign(void)
{
#ifdef TARGET_X64

  __asm {
    mov rdx, qword ptr [rax];
    mov rcx, rdx;
    shr rdx, 32;
    and edx, 0x7FF00000;
    jz label_0;
    cmp edx, 0x7FF00000;
    je label_0;
    jmp label_1;
label_0:
    
    sub rcx, rcx;
label_1:
    
    mov qword ptr [edi], rcx;
    mov rax, rdi;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

#else

  __asm {
    mov edx, dword ptr [eax+4];
    mov ecx, dword ptr [eax];
    and edx, 0x7ff00000;
    jz label_2;   // if exponent=zero, zero
    cmp edx, 0x7ff00000;
    je label_2; // if exponent=all 1s, zero
    mov edx, dword ptr [eax+4]; // reread
    jmp label_3;
label_2:
    
    sub ecx, ecx;
    sub edx, edx;
label_3:
    
    mov dword ptr [edi], ecx;
    mov dword ptr [edi+4], edx;
    mov eax, edi;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif
}
__declspec(naked) void nseel_asm_assign_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_assign_fromfp(void)
{
#ifdef TARGET_X64

  __asm {
    fstp qword ptr [rdi];
    mov rdx, qword ptr [rdi];
    mov r15, 0x7FF0000000000000;
    and rdx, r15;
    jz label_4;
    cmp rdx, r15;
    jne label_5;
label_4:
    
    sub rcx, rcx;
    mov qword ptr [rdi], rcx;
label_5:
    
    mov rax, rdi;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

#else

  __asm {
    fstp qword ptr [edi];
    mov edx, dword ptr [edi+4];
    and edx, 0x7ff00000;
    jz label_6;
    cmp edx, 0x7ff00000;
    jne label_7;
label_6:
    
      fldz;
      fstp qword ptr [edi];
label_7:
    
    mov eax, edi;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif
}
__declspec(naked) void nseel_asm_assign_fromfp_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_assign_fast(void)
{
#ifdef TARGET_X64

  __asm {
    mov rdx, qword ptr [rax];
    mov qword ptr [edi], rdx;
    mov rax, rdi;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

#else

  __asm {
    mov edx, dword ptr [eax+4];
    mov ecx, dword ptr [eax];
    mov dword ptr [edi], ecx;
    mov dword ptr [edi+4], edx;
    mov eax, edi;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif
}
__declspec(naked) void nseel_asm_assign_fast_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_add(void)
{
  __asm {
    fadd;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_add_end(void) {}

__declspec(naked) void nseel_asm_add_op(void)
{
  __asm {
    fadd EEL_ASM_TYPE [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_add_op_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_sub(void)
{
  __asm {
#ifdef __GNUC__
    fsubr; // gnuc has fsub/fsubr backwards, ack
#else
    fsub;
#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_sub_end(void) {}

__declspec(naked) void nseel_asm_sub_op(void)
{
  __asm {
    fsubr EEL_ASM_TYPE [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_sub_op_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_mul(void)
{
  __asm {
    fmul;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_mul_end(void) {}

__declspec(naked) void nseel_asm_mul_op(void)
{
  __asm {
    fmul EEL_ASM_TYPE [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_mul_op_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_div(void)
{
  __asm {
#ifdef __GNUC__
    fdivr; // gcc inline asm seems to have fdiv/fdivr backwards
#else
    fdiv;
#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_div_end(void) {}

__declspec(naked) void nseel_asm_div_op(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
#ifndef __GNUC__
    fxch; // gcc inline asm seems to have fdiv/fdivr backwards
#endif
    fdiv;
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_div_op_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_mod(void)
{
  __asm {
    fabs;
    fistp dword ptr [esi];
    fabs;
    fistp dword ptr [esi+4];
    xor edx, edx;
#ifdef TARGET_X64
    sub eax, eax;
#endif
    cmp dword ptr [esi], 0;
    je label_8; // skip devide, set return to 0
    mov eax, dword ptr [esi+4];
    div dword ptr [esi];
label_8:
    
    mov dword ptr [esi], edx;
    fild dword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_mod_end(void) {}

__declspec(naked) void nseel_asm_shl(void)
{
  __asm {
    fistp dword ptr [esi];
    fistp dword ptr [esi+4];
    mov ecx, dword ptr [esi];
    mov eax, dword ptr [esi+4];
    shl eax, cl;
    mov dword ptr [esi], eax;
    fild dword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_shl_end(void) {}

__declspec(naked) void nseel_asm_shr(void)
{
  __asm {
    fistp dword ptr [esi];
    fistp dword ptr [esi+4];
    mov ecx, dword ptr [esi];
    mov eax, dword ptr [esi+4];
    sar eax, cl;
    mov dword ptr [esi], eax;
    fild dword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_shr_end(void) {}


__declspec(naked) void nseel_asm_mod_op(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
    fxch;
    fabs;
    fistp dword ptr [edi];
    fabs;
    fistp dword ptr [esi];
#ifdef TARGET_X64
    sub eax, eax;
#endif
    xor edx, edx;
    cmp dword ptr [edi], 0;
    je label_9; // skip devide, set return to 0
    mov eax, dword ptr [esi];
    div dword ptr [edi];
label_9:
    
    mov dword ptr [edi], edx;
    fild dword ptr [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }
}
__declspec(naked) void nseel_asm_mod_op_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_or(void)
{
  __asm {
    fistp qword ptr [esi];
    fistp qword ptr [esi+8];
#ifdef TARGET_X64
    mov rdi, qword ptr [rsi+8];
    or qword ptr [rsi], rdi;
#else
    mov edi, dword ptr [esi+8];
    mov ecx, dword ptr [esi+12];
    or dword ptr [esi], edi;
    or dword ptr [esi+4], ecx;
#endif
    fild qword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_or_end(void) {}

__declspec(naked) void nseel_asm_or0(void)
{
  __asm {
    frndint;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_or0_end(void) {}

__declspec(naked) void nseel_asm_or_op(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
    fxch;
    fistp qword ptr [edi];
    fistp qword ptr [esi];
#ifdef TARGET_X64
    mov rax, qword ptr [rsi];
    or qword ptr [rdi], rax;
#else
    mov eax, dword ptr [esi];
    mov ecx, dword ptr [esi+4];
    or dword ptr [edi], eax;
    or dword ptr [edi+4], ecx;
#endif
    fild qword ptr [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_or_op_end(void) {}


__declspec(naked) void nseel_asm_xor(void)
{
  __asm {
    fistp qword ptr [esi];
    fistp qword ptr [esi+8];
#ifdef TARGET_X64
    mov rdi, qword ptr [rsi+8];
    xor qword ptr [rsi], rdi;
#else
    mov edi, dword ptr [esi+8];
    mov ecx, dword ptr [esi+12];
    xor dword ptr [esi], edi;
    xor dword ptr [esi+4], ecx;
#endif
    fild qword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_xor_end(void) {}

__declspec(naked) void nseel_asm_xor_op(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
    fxch;
    fistp qword ptr [edi];
    fistp qword ptr [esi];
#ifdef TARGET_X64
    mov rax, qword ptr [rsi];
    xor qword ptr [rdi], rax;
#else
    mov eax, dword ptr [esi];
    mov ecx, dword ptr [esi+4];
    xor dword ptr [edi], eax;
    xor dword ptr [edi+4], ecx;
#endif
    fild qword ptr [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_xor_op_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_and(void)
{
  __asm {
    fistp qword ptr [esi];
    fistp qword ptr [esi+8];
#ifdef TARGET_X64
    mov rdi, qword ptr [rsi+8];
    and qword ptr [rsi], rdi;
#else
    mov edi, dword ptr [esi+8];
    mov ecx, dword ptr [esi+12];
    and dword ptr [esi], edi;
    and dword ptr [esi+4], ecx;
#endif
    fild qword ptr [esi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_and_end(void) {}

__declspec(naked) void nseel_asm_and_op(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
    fxch;
    fistp qword ptr [edi];
    fistp qword ptr [esi];
#ifdef TARGET_X64
    mov rax, qword ptr [rsi];
    and qword ptr [rdi], rax;
#else
    mov eax, dword ptr [esi];
    mov ecx, dword ptr [esi+4];
    and dword ptr [edi], eax;
    and dword ptr [edi+4], ecx;
#endif
    fild qword ptr [edi];
    mov eax, edi;
    fstp EEL_ASM_TYPE [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_and_op_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_uplus(void) // this is the same as doing nothing, it seems
{
   __asm {
      
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }
}
__declspec(naked) void nseel_asm_uplus_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_uminus(void)
{
  __asm {
    fchs;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_uminus_end(void) {}



//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_sign(void)
{
  __asm {

#ifdef TARGET_X64


    fst EEL_ASM_TYPE [rsp+-8];
    mov rdx, EEL_ASM_TYPE [rsp+-8];
    mov rcx, 0x7FFFFFFFFFFFFFFF;
    test rdx, rcx;
    jz label_10; // zero zero, return the value passed directly
      // calculate sign
      inc rcx; // rcx becomes 0x80000...
      fstp st(0);
      fld1;
      test rdx, rcx;
      jz label_10;
      fchs;
label_10:
  	

#else

    fst dword ptr [esp+-4];
    mov ecx, dword ptr [esp+-4];
    mov edx, 0x7FFFFFFF;
    test ecx, edx;
    jz label_11; // zero zero, return the value passed directly
      // calculate sign
      inc edx; // edx becomes 0x8000...
      fstp st(0);
      fld1;
      test ecx, edx;
      jz label_11;
      fchs;
label_11:
  	

#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
}
}
__declspec(naked) void nseel_asm_sign_end(void) {}



//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_bnot(void)
{
  __asm {
    test eax, eax;
    setz al;
    and eax, 0xff;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_bnot_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_if(void) // not currently used on x86/x86-64
{
  __asm {
#ifdef TARGET_X64
    sub rsp, 8;
    test eax, eax;
    jz label_12;
    mov rax, 0xfefefefe;
    call eax;
    jmp label_13;
label_12:
    
    mov rax, 0xfefefefe;
    call eax;
label_13:
    
    add rsp, 8;
#else
    sub esp, 12;
    test eax, eax;
    jz label_14;
    mov eax, 0xfefefefe;
    call eax;
    jmp label_15;
label_14:
    
    mov eax, 0xfefefefe;
    call eax;
label_15:
    
    add esp, 12;
#endif

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_if_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_repeat(void)
{
  __asm {
#ifdef TARGET_X64
    fistp qword ptr [esi];
    mov rcx, qword ptr [rsi];
#else
    fistp dword ptr [esi];
    mov ecx, dword ptr [esi];
#endif
    cmp ecx, 1;
    jl label_16;
    cmp ecx, NSEEL_LOOPFUNC_SUPPORT_MAXLEN;
    jl label_17;
    mov ecx, NSEEL_LOOPFUNC_SUPPORT_MAXLEN;
label_17:

      mov edx, 0xfefefefe;
#ifdef TARGET_X64
      sub esp, 8; /* keep stack aligned to 16 byte */
#else
      sub esp, 4; /* keep stack aligned to 16 byte */
#endif
      push esi; // revert back to last temp workspace
      push ecx;

      call edx;

      pop ecx;
      pop esi;
#ifdef TARGET_X64
      add esp, 8; /* keep stack aligned to 16 byte */
#else
      add esp, 4; /* keep stack aligned to 16 byte */
#endif
    dec ecx;
    jnz label_17;
label_16:

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_repeat_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_fcall(void)
{
  __asm {
     mov edx, 0xfefefefe;
#ifdef TARGET_X64
     sub esp, 8;
     call edx;
     add esp, 8;
#else
     sub esp, 12; /* keep stack 16 byte aligned, 4 bytes for return address */
     call edx;
     add esp, 12;
#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_fcall_end(void) {}

__declspec(naked) void nseel_asm_repeatwhile(void)
{
  __asm {
    mov ecx, NSEEL_LOOPFUNC_SUPPORT_MAXLEN;
label_18:

      mov edx, 0xfefefefe;

#ifdef TARGET_X64
      sub esp, 8; /* keep stack aligned -- required on x86 and x64*/
#else
      sub esp, 4; /* keep stack aligned -- required on x86 and x64*/
#endif
      push esi; // revert back to last temp workspace
      push ecx;
      call edx;
      pop ecx;
      pop esi;
#ifdef TARGET_X64
      add esp, 8; /* keep stack aligned -- required on x86 and x64 */
#else
      add esp, 4; /* keep stack aligned -- required on x86 and x64 */
#endif
	  test eax, eax;
	  jz label_19;
    dec ecx;
    jnz label_18;
label_19:
	
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_repeatwhile_end(void) {}


__declspec(naked) void nseel_asm_band(void)
{
  __asm {
    test eax, eax;
    jz label_20;

     mov ecx, 0xfefefefe;
#ifdef TARGET_X64
        sub rsp, 8;
#else
        sub esp, 12;
#endif
        call ecx;
#ifdef TARGET_X64
        add rsp, 8;
#else
        add esp, 12;
#endif
label_20:
    
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_band_end(void) {}

__declspec(naked) void nseel_asm_bor(void)
{
  __asm {
    test eax, eax;
    jnz label_21;

    mov ecx, 0xfefefefe;
#ifdef TARGET_X64
    sub rsp, 8;
#else
    sub esp, 12;
#endif
    call ecx;
#ifdef TARGET_X64
    add rsp, 8;
#else
    add esp, 12;
#endif
label_21:
    
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_bor_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_equal(void)
{
  __asm {
    fsub;
    fabs;
#ifdef TARGET_X64
    mov rax, 0xfefefefe;
    fcomp EEL_ASM_TYPE [rax]; //[g_closefact]
#else
#if EEL_F_SIZE == 8
_emit 0xDC; // fcomp qword ptr [0xfefefefe]
_emit 0x1D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fcomp dword ptr [0xfefefefe]
_emit 0x1D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
#endif
    fstsw ax;
    and eax, 256; // old behavior: if 256 set, true (NaN means true)
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_equal_end(void) {}
//
//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_notequal(void)
{
  __asm {
    fsub;
    fabs;
#ifdef TARGET_X64
    mov rax, 0xfefefefe;
    fcomp EEL_ASM_TYPE [rax]; //[g_closefact]
#else
#if EEL_F_SIZE == 8
_emit 0xDC; // fcomp qword ptr [0xfefefefe]
_emit 0x1D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fcomp dword ptr [0xfefefefe]
_emit 0x1D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
#endif
    fstsw ax;
    and eax, 256;
    xor eax, 256; // old behavior: if 256 set, FALSE (NaN makes for false)
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_notequal_end(void) {}


//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_above(void)
{
  __asm {
    fcompp;
    fstsw ax;
    and eax, 1280; //  (1024+256) old behavior: NaN would mean 1, preserve that
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_above_end(void) {}

//---------------------------------------------------------------------------------------------------------------
__declspec(naked) void nseel_asm_beloweq(void)
{
  __asm {
    fcompp;
    fstsw ax;
    and eax, 256; // old behavior: NaN would be 0 (ugh)
    xor eax, 256;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_beloweq_end(void) {}


__declspec(naked) void nseel_asm_booltofp(void)
{
  __asm {
    test eax, eax;
    jz label_22;
    fld1;
    jmp label_23;
label_22:
    
    fldz;
label_23:
    
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_booltofp_end(void) {}

__declspec(naked) void nseel_asm_fptobool(void)
{
  __asm {
    fabs;
#ifdef TARGET_X64
    mov rax, 0xfefefefe;
    fcomp EEL_ASM_TYPE [rax]; //[g_closefact]
#else
#if EEL_F_SIZE == 8
_emit 0xDC; // fcomp qword ptr [0xfefefefe]
_emit 0x1D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fcomp dword ptr [0xfefefefe]
_emit 0x1D;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
#endif
    fstsw ax;
    and eax, 256;
    xor eax, 256;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }
}
__declspec(naked) void nseel_asm_fptobool_end(void) {}


__declspec(naked) void nseel_asm_min(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
    fcomp EEL_ASM_TYPE [eax];
    push eax;
    fstsw ax;
    test eax, 256;
    pop eax;
    jz label_24;
    mov eax, edi;
label_24:
    
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

}
__declspec(naked) void nseel_asm_min_end(void) {}

__declspec(naked) void nseel_asm_max(void)
{
  __asm {
    fld EEL_ASM_TYPE [edi];
    fcomp EEL_ASM_TYPE [eax];
    push eax;
    fstsw ax;
    test eax, 256;
    pop eax;
    jnz label_25;
    mov eax, edi;
label_25:
    
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }
}
__declspec(naked) void nseel_asm_max_end(void) {}



__declspec(naked) void nseel_asm_min_fp(void)
{
  __asm {
    fcom;
    fstsw ax;
    test eax, 256;
    jz label_26;
    fxch;
label_26:
    
    fstp st(0);
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

}
__declspec(naked) void nseel_asm_min_fp_end(void) {}

__declspec(naked) void nseel_asm_max_fp(void)
{
  __asm {
    fcom;
    fstsw ax;
    test eax, 256;
    jnz label_27;
    fxch;
label_27:
    
    fstp st(0);
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }
}
__declspec(naked) void nseel_asm_max_fp_end(void) {}



// just generic functions left, yay




__declspec(naked) void _asm_generic3parm(void)
{
  __asm {
#ifdef TARGET_X64

#ifdef AMD64ABI

    mov r15, rsi;
    mov rdx, rdi; // third parameter = parm
    mov rdi, 0xfefefefe; // first parameter= context

    mov rsi, ecx; // second parameter = parm
    mov rcx, rax; // fourth parameter = parm
    mov rax, 0xfefefefe; // call function
    sub rsp, 128;
    call rax;

    mov rsi, r15;
    add rsp, 128;

#else
    mov edx, ecx; // second parameter = parm
    mov ecx, 0xfefefefe; // first parameter= context
    mov r8, rdi; // third parameter = parm
    mov r9, rax; // fourth parameter = parm
    mov edi, 0xfefefefe; // call function
    sub rsp, 128;
    call edi;
    add rsp, 128;
#endif

#else

    mov edx, 0xfefefefe;
    push eax; // push parameter
    push edi; // push parameter
    push ecx; // push parameter
    push edx; // push context pointer
    mov edi, 0xfefefefe;
    call edi;
    add esp, 16;

#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}
__declspec(naked) void _asm_generic3parm_end(void) {}


__declspec(naked) void _asm_generic3parm_retd(void)
{
  __asm {
#ifdef TARGET_X64
#ifdef AMD64ABI
    mov r15, rsi;
    mov rdx, rdi; // third parameter = parm
    mov rdi, 0xfefefefe; // first parameter= context
    mov rsi, ecx; // second parameter = parm
    mov rcx, rax; // fourth parameter = parm
    mov rax, 0xfefefefe; // call function
    sub rsp, 128;
    call rax;
    mov rsi, r15;
#else
    mov edx, ecx; // second parameter = parm
    mov ecx, 0xfefefefe; // first parameter= context
    mov r8, rdi; // third parameter = parm
    mov r9, rax; // fourth parameter = parm
    mov edi, 0xfefefefe; // call function
    sub rsp, 128;
    call edi;
#endif
    movq [rsp], xmm0;
    fld qword ptr [rsp];
    add rsp, 128;
#else

    sub esp, 16;
    mov dword ptr [esp+8], edi;
    mov edx, 0xfefefefe;
    mov edi, 0xfefefefe;
    mov dword ptr [esp+12], eax;
    mov dword ptr [esp+4], ecx;
    mov dword ptr [esp], edx;
    call edi;
    add esp, 16;

#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}
__declspec(naked) void _asm_generic3parm_retd_end(void) {}


__declspec(naked) void _asm_generic2parm(void) // this prob neds to be fixed for ppc
{
  __asm {
#ifdef TARGET_X64

#ifdef AMD64ABI
    mov r15, rsi;
    mov esi, edi; // second parameter = parm
    mov edi, 0xfefefefe; // first parameter= context
    mov rdx, rax; // third parameter = parm
    mov rcx, 0xfefefefe; // call function
    sub rsp, 128;
    call rcx;
    mov rsi, r15;
    add rsp, 128;
#else
    mov ecx, 0xfefefefe; // first parameter= context
    mov edx, edi; // second parameter = parm
    mov r8, rax; // third parameter = parm
    mov edi, 0xfefefefe; // call function
    sub rsp, 128;
    call edi;
    add rsp, 128;
#endif
#else

    mov edx, 0xfefefefe;
    sub esp, 4; // keep stack aligned
    push eax; // push parameter
    push edi; // push parameter
    push edx; // push context pointer
    mov edi, 0xfefefefe;
    call edi;
    add esp, 16;

#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}
__declspec(naked) void _asm_generic2parm_end(void) {}


__declspec(naked) void _asm_generic2parm_retd(void)
{
  __asm {
#ifdef TARGET_X64
#ifdef AMD64ABI
    mov r15, rsi;
    mov rsi, rdi; // second parameter = parm
    mov rdi, 0xfefefefe; // first parameter= context
    mov rcx, 0xfefefefe; // call function
    mov rdx, rax; // third parameter = parm
    sub rsp, 128;
    call rcx;
    mov rsi, r15;
#else
    mov rdx, rdi; // second parameter = parm
    mov rcx, 0xfefefefe; // first parameter= context
    mov rdi, 0xfefefefe; // call function
    mov r8, rax; // third parameter = parm
    sub rsp, 128;
    call edi;
#endif
    movq [rsp], xmm0;
    fld qword ptr [rsp];
    add rsp, 128;
#else

    sub esp, 16;
    mov edx, 0xfefefefe;
    mov ecx, 0xfefefefe;
    mov dword ptr [esp], edx;
    mov dword ptr [esp+4], edi;
    mov dword ptr [esp+8], eax;
    call ecx;
    add esp, 16;

#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}
__declspec(naked) void _asm_generic2parm_retd_end(void) {}





__declspec(naked) void _asm_generic1parm(void)
{
  __asm {
#ifdef TARGET_X64
#ifdef AMD64ABI
    mov rdi, 0xfefefefe; // first parameter= context
    mov r15, rsi;
    mov rsi, eax; // second parameter = parm
    sub rsp, 128;
    mov rcx, 0xfefefefe; // call function
    call rcx;
    mov rsi, r15;
    add rsp, 128;
#else
    mov ecx, 0xfefefefe; // first parameter= context
    mov edx, eax; // second parameter = parm
    mov edi, 0xfefefefe; // call function
    sub rsp, 128;
    call edi;
    add rsp, 128;
#endif
#else

    mov edx, 0xfefefefe;
    sub esp, 8; // keep stack aligned
    push eax; // push parameter
    push edx; // push context pointer
    mov edi, 0xfefefefe;
    call edi;
    add esp, 16;

#endif

_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}
__declspec(naked) void _asm_generic1parm_end(void) {}


__declspec(naked) void _asm_generic1parm_retd(void) // 1 parameter returning double
{
  __asm {
#ifdef TARGET_X64
    sub rsp, 128;
#ifdef AMD64ABI
    mov rdi, 0xfefefefe; // first parameter = context pointer
    mov rcx, 0xfefefefe; // function address
    mov r15, rsi; // save rsi
    mov rsi, rax; // second parameter = parameter

    call rcx;

    mov rsi, r15;
#else
    mov ecx, 0xfefefefe; // first parameter= context
    mov edi, 0xfefefefe; // call function

    mov rdx, rax; // second parameter = parm

    call edi;
#endif
    movq [rsp], xmm0;
    fld qword ptr [rsp];
    add rsp, 128;
#else

    mov edx, 0xfefefefe; // context pointer
    mov edi, 0xfefefefe; // func-addr
    sub esp, 16;
    mov dword ptr [esp+4], eax; // push parameter
    mov dword ptr [esp], edx; // push context pointer
    call edi;
    add esp, 16;

#endif
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}
__declspec(naked) void _asm_generic1parm_retd_end(void) {}





// this gets its own stub because it's pretty crucial for performance :/

__declspec(naked) void _asm_megabuf(void)
{
  __asm {


#ifdef TARGET_X64


#ifdef AMD64ABI

    mov rdi, 0xfefefefe; // first parameter = context pointer

    mov rdx, 0xfefefefe;

    fadd EEL_ASM_TYPE [rdx];
    fistp dword ptr [rsi];
    sub rdx, rdx;

    // check if (%rsi) is in range, and buffer available, otherwise call function
    mov edx, dword ptr [rsi];
    test rdx, 0xff800000; // 0xFFFFFFFF - (NSEEL_RAM_BLOCKS*NSEEL_RAM_ITEMSPERBLOCK - 1)
    jnz label_28;
    mov rax, rdx;
    shr rax, 13;     // log2(NSEEL_RAM_ITEMSPERBLOCK) - log2(sizeof(void*))
    and rax, 0x3F8;  // (NSEEL_RAM_BLOCKS-1)*sizeof(void*)
    mov rax, qword ptr [rdi+rax];
    test rax, rax;
    jz label_28;
    and rdx, 0xFFFF; // (NSEEL_RAM_ITEMSPERBLOCK-1)
    shl rdx, 3;      // log2(sizeof(EEL_F))
    add rax, rdx;
    jmp label_29;


label_28:
    
    mov r15, rsi; // save rsi
    mov esi, rdx; // esi becomes second parameter (edi is first, context pointer)
    mov edx, 0xfefefefe;
    sub rsp, 128;
    call edx;
    mov rsi, r15; // restore rsi
    add rsp, 128;
label_29:
    

#else
    mov ecx, 0xfefefefe; // first parameter = context pointer
    mov edx, 0xfefefefe;
    sub rdi, rdi;

    fadd EEL_ASM_TYPE [rdx];

    fistp dword ptr [esi];

    // check if (%esi) is in range...
    mov edi, dword ptr [rsi];
    test edi, 0xff800000;   // 0xFFFFFFFF - (NSEEL_RAM_BLOCKS*NSEEL_RAM_ITEMSPERBLOCK - 1)
    jnz label_30;
    mov rax, rdi;
    shr rax, 13;           // log2(NSEEL_RAM_ITEMSPERBLOCK) - log2(sizeof(void*))
    and rax, 0x3F8;        // (NSEEL_RAM_BLOCKS-1)*sizeof(void*)
    mov rax, qword ptr [rcx+rax];
    test rax, rax;
    jz label_30;
    and rdi, 0xFFFF;   // (NSEEL_RAM_ITEMSPERBLOCK-1)
    shl rdi, 3;        // log2(sizeof(EEL_F))
    add rax, rdi;
    jmp label_31;

label_30:
    
    mov rdx, rdi; // rdx is second parameter (rcx is first)
    mov edi, 0xfefefefe; // function ptr
    sub rsp, 128;
    call edi;
    add rsp, 128;
label_31:
    
#endif


#else
    mov edx, 0xfefefefe;
#if EEL_F_SIZE == 8
_emit 0xDC; // fadd qword ptr [0xfefefefe]
_emit 0x05;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fadd dword ptr [0xfefefefe]
_emit 0x05;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
    fistp dword ptr [esi];

    // check if (%esi) is in range, and buffer available, otherwise call function
    mov edi, dword ptr [esi];
    test edi, 0xff800000;  // 0xFFFFFFFF - (NSEEL_RAM_BLOCKS*NSEEL_RAM_ITEMSPERBLOCK - 1)
    jnz label_32;

    mov eax, edi;
    shr eax, 14;            // log2(NSEEL_RAM_ITEMSPERBLOCK) - log2(sizeof(void *))
    and eax, 0x1FC;    // (NSEEL_RAM_BLOCKS-1)*sizeof(void*)
    mov eax, dword ptr [edx+eax];
    test eax, eax;
    jz label_32;
    and edi, 0xFFFF;  // (NSEEL_RAM_ITEMSPERBLOCK-1)
    shl edi, 3;       // log2(sizeof(EEL_F))
    add eax, edi;
    jmp label_33;


label_32:
    
    sub esp, 8; // keep stack aligned
    push edi; // parameter
    push edx; // push context pointer
    mov edi, 0xfefefefe;
    call edi;
    add esp, 16;

label_33:
    


#endif



_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}

__declspec(naked) void _asm_megabuf_end(void) {}


__declspec(naked) void _asm_gmegabuf(void)
{
  __asm {


#ifdef TARGET_X64


#ifdef AMD64ABI

    mov r15, rsi;
    mov rdi, 0xfefefefe; // first parameter = context pointer
    mov rdx, 0xfefefefe;
    fadd EEL_ASM_TYPE [rdx];
    fistp dword ptr [r15];
    xor rsi, rsi;
    mov esi, dword ptr [r15]; // r15 = esi (from above)
    mov edx, 0xfefefefe;
    sub rsp, 128;
    call edx;
    mov rsi, r15;
    add rsp, 128;

#else
    mov ecx, 0xfefefefe; // first parameter = context pointer
    mov edx, 0xfefefefe;
    fadd EEL_ASM_TYPE [rdx];
    fistp dword ptr [esi];
    xor rdx, rdx;
    mov edx, dword ptr [esi];
    mov edi, 0xfefefefe;
    sub rsp, 128;
    call edi;
    add rsp, 128;
#endif


#else
    mov edx, 0xfefefefe;
#if EEL_F_SIZE == 8
_emit 0xDC; // fadd qword ptr [0xfefefefe]
_emit 0x05;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#else
_emit 0xD8; // fadd dword ptr [0xfefefefe]
_emit 0x05;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
_emit 0xFE;
#endif
    fistp dword ptr [esi];
    sub esp, 8; // keep stack aligned
    push dword ptr [esi]; // parameter
    push edx; // push context pointer
    mov edi, 0xfefefefe;
    call edi;
    add esp, 16;

#endif



_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
 }
}

__declspec(naked) void _asm_gmegabuf_end(void) {}

__declspec(naked) void nseel_asm_stack_push(void)
{
#ifdef TARGET_X64
  __asm {
    mov rdi, 0xfefefefe;
    mov rcx, qword ptr [rax];
    mov rax, qword ptr [rdi];
    add rax, 8;
    mov rdx, 0xFEFEFEFE;
    and rax, rdx;
    mov rdx, 0xFEFEFEFE;
    or rax, rdx;
    mov qword ptr [rax], rcx;
    mov qword ptr [rdi], rax;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }
#else

  __asm {
    mov edi, 0xfefefefe;

    mov ecx, dword ptr [eax];
    mov edx, dword ptr [eax+4];

    mov eax, dword ptr [edi];

    add eax, 8;
    and eax, 0xfefefefe;
    or eax, 0xfefefefe;

    mov dword ptr [eax], ecx;
    mov dword ptr [eax+4], edx;

    mov dword ptr [edi], eax;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif

}
__declspec(naked) void nseel_asm_stack_push_end(void) {}



__declspec(naked) void nseel_asm_stack_pop(void)
{
#ifdef TARGET_X64

  __asm {
      mov rdi, 0xfefefefe;
      mov rcx, qword ptr [rdi];
      movq xmm0, [rcx];
      sub rcx, 8;
      mov rdx, 0xFEFEFEFE;
      and rcx, rdx;
      mov rdx, 0xFEFEFEFE;
      or rcx, rdx;
      mov qword ptr [rdi], rcx;
      movq [eax], xmm0;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

#else

  __asm {
    mov edi, 0xfefefefe;
    mov ecx, dword ptr [edi];
    fld EEL_ASM_TYPE [ecx];
    sub ecx, 8;
    and ecx, 0xfefefefe;
    or ecx, 0xfefefefe;
    mov dword ptr [edi], ecx;
    fstp EEL_ASM_TYPE [eax];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif
}
__declspec(naked) void nseel_asm_stack_pop_end(void) {}


__declspec(naked) void nseel_asm_stack_pop_fast(void)
{
#ifdef TARGET_X64

  __asm {
      mov rdi, 0xfefefefe;
      mov rcx, qword ptr [rdi];
      mov rax, rcx;
      sub rcx, 8;
      mov rdx, 0xFEFEFEFE;
      and rcx, rdx;
      mov rdx, 0xFEFEFEFE;
      or rcx, rdx;
      mov qword ptr [rdi], rcx;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
    }

#else

  __asm {
    mov edi, 0xfefefefe;
    mov ecx, dword ptr [edi];
    mov eax, ecx;
    sub ecx, 8;
    and ecx, 0xfefefefe;
    or ecx, 0xfefefefe;
    mov dword ptr [edi], ecx;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif
}
__declspec(naked) void nseel_asm_stack_pop_fast_end(void) {}

__declspec(naked) void nseel_asm_stack_peek_int(void)
{
#ifdef TARGET_X64

  __asm {
    mov rdi, 0xfefefefe;
    mov rax, qword ptr [rdi];
    mov rdx, 0xfefefefe;
    sub rax, rdx;
    mov rdx, 0xFEFEFEFE;
    and rax, rdx;
    mov rdx, 0xFEFEFEFE;
    or rax, rdx;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#else

  __asm {
    mov edi, 0xfefefefe;
    mov eax, dword ptr [edi];
    mov edx, 0xfefefefe;
    sub eax, edx;
    and eax, 0xfefefefe;
    or eax, 0xfefefefe;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif

}
__declspec(naked) void nseel_asm_stack_peek_int_end(void) {}



__declspec(naked) void nseel_asm_stack_peek(void)
{
#ifdef TARGET_X64

  __asm {
    mov rdi, 0xfefefefe;
    fistp dword ptr [rsi];
    mov rax, qword ptr [rdi];
    mov rdx, qword ptr [rsi];
    shl rdx, 3; // log2(sizeof(EEL_F))
    sub rax, rdx;
    mov rdx, 0xFEFEFEFE;
    and rax, rdx;
    mov rdx, 0xFEFEFEFE;
    or rax, rdx;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#else

  __asm {
    mov edi, 0xfefefefe;
    fistp dword ptr [esi];
    mov eax, dword ptr [edi];
    mov edx, dword ptr [esi];
    shl edx, 3; // log2(sizeof(EEL_F))
    sub eax, edx;
    and eax, 0xfefefefe;
    or eax, 0xfefefefe;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif

}
__declspec(naked) void nseel_asm_stack_peek_end(void) {}


__declspec(naked) void nseel_asm_stack_peek_top(void)
{
#ifdef TARGET_X64

  __asm {
    mov rdi, 0xfefefefe;
    mov rax, qword ptr [rdi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#else

  __asm {
    mov edi, 0xfefefefe;
    mov eax, dword ptr [edi];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif

}
__declspec(naked) void nseel_asm_stack_peek_top_end(void) {}

__declspec(naked) void nseel_asm_stack_exch(void)
{
#ifdef TARGET_X64

  __asm {
    mov rdi, 0xfefefefe;
    mov rcx, qword ptr [rdi];
    movq xmm0, [rcx];
    movq xmm1, [rax];
    movq [rax], xmm0;
    movq [rcx], xmm1;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#else

  __asm {
    mov edi, 0xfefefefe;
    mov ecx, dword ptr [edi];
    fld EEL_ASM_TYPE [ecx];
    fld EEL_ASM_TYPE [eax];
    fstp EEL_ASM_TYPE [ecx];
    fstp EEL_ASM_TYPE [eax];
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
  }

#endif

}
__declspec(naked) void nseel_asm_stack_exch_end(void) {}

#ifdef TARGET_X64
__declspec(naked) void win64_callcode()
{
	__asm {
#ifdef AMD64ABI
		mov eax, edi;
#else
		mov eax, ecx;
#endif

		push rbx;
		push rbp;
#ifndef AMD64ABI
		push rdi;
		push rsi;
		push r12;
		push r13;
#endif
		push r14; // on AMD64ABI, we'll use r14/r15 to save edi/esi
		push r15;
		call eax;
		pop r15;
		pop r14;
#ifndef AMD64ABI
		pop r13;
		pop r12;
		pop rsi;
		pop rdi;
		fclex;
#endif
		pop rbp;
		pop rbx;
		ret;
_emit 0x89;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
_emit 0x90;
	}
}

#endif
